Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.4

====== Flowchart FC-2370 Incorporation in Comanche 67 ======

([[comanche-67-reconstruction|Return to the main Comanche 67 reconstruction page.]])

==== Executive Summary ====

I believe I've implemented FC-2370 into the reconstructed code, including PCR-815 (BBQ Mode). I say "implemented" rather than "incorporated" because I doubt some of the details. Several proprocessor constants for conditional assembly had to be introduced; see the table. There were quite a few points at which PCR-815 could have been implemented differently than I did, which will all need to be revisited, perhaps many times. Memory banks 43 and 16 were completely filled in the implementation process, but no memory banks were made to overflow. Unfortunately, these changes did not cause any dramatic improvement in banksum discrepancies. In fact, the "goodness signature" remains identical before-vs-after 08-02-04-06-04-10-02. So it is likely that the implementation was incorrect in many details.

==== Flowchart-To-Flowchart Comparison ====

We have the Colossus 2A and Colossus 2D revisions of the flowchart. My strategy will be to do a side-by-side comparison of these two revisions to determine potential code changes in 2D. I will then try to determine what, if any, actions are required to reconstruct Colossus 2C.

* STABLISH: 2A/2 vs 2D/2: Matches.
* NODAPUP: 2A/2 vs 2D/2,3: Matches.
* RCSDAPUP: 2A/3 vs 2D/4: Matches.
* SATSTKON: 2A/4 vs 2D/5: Matches
* DAPDISP: 2A/5 vs 2D/6: Matches
* DONOUN46: 2A/5,6 vs 2D/7,8: Matches
* DONOUN47: 2A/6,7 vs 2D/8,9: Matches
* DONOUN48: 2A/7 vs 2D/10: Matches
* V79, RATEMANU, RATECOMP, PTCROLL: 2A/absent vs 2D/10,11,12: Refer to the V79 section.
* S41.2 //et al.//: 2A/8,9 vs 2D/13,14,15,16: Matches. But there are some provisos:
	* The 2D flowchart goes out of its way to set/clear ATTCHFLG, whereas the 2A flowchart instead says "bit 2 of FLAGWRD7". These are admittedly the same. Correspondingly, in the Comanche 55 code you find that BIT2 is used to mask FLAGWRD7, whereas in Artemis you find that ATTCHBIT masks FLAGWRD7. ATTCHBIT = BIT2, so there's no change in the core-rope values. Nevertheless, I've added this change to Comanche 67, conditionally assembled according to the preprocessor symbol ReconstructionFC2370.
	* Similarly, what is "bit 15 of FLAGWRD1" in the 2A flowchart is "NJETSFLG" in the 2D flowchart. Thus I've changed BIT15 to NJETSFLG in the reconstruction, again conditioned on ReconstructionFC2370.
	* And something else I noticed: In Comanche 55, S41.2 is positioned near the end of the log section, whereas in Artemis it's much closer to the middle ... i.e., the ordering of the source code (in section P40-P47) has changed. Of course, that could mean nothing, and so far I've done nothing with it.
* S40.14: 2A/10 vs 2D/17: Matches.
* S40.15: 2A/absent vs 2D/17: Matched the reconstructed code. (The code actually already had changes, just to the comments, previously incorporated due to PCR-811.)
* ENATMA: 2A/11 vs 2D/18: Mismatch, however the difference was already incorporated due to PCR-785.
* V60: 2A/12 vs 2D/18: Mismatch. The variables referred to in the 2A flowchart as CPHI, CTHETA, CPSI are referred to in the 2D flowchart as CPHIX, CPHIX +1, CPHIX +2. In point of fact, though, Comanche 55 source code already uses CPHIX, in spite of what the flowchart say. I do notice that CPHIX is at a different location in Artemis erasable than in Comanche 55 erasable, but have no way to know if that's relevant or not.
* V61: 2A/12 vs 2D/18: Matches. The 2A flowchart refers to "bit 9 of FLAGWRD0" whereas the 2D flowchart refers to "NEEDLFLG". However, Comanche 55 code already used NEEDLFLG, regardless of flowchart.
* V62: 2A/12 vs 2D/19: Matches. Same comment as for V61.
* V63: 2A/13 vs 2D/19: Matches. Same comment as for V61.
* NEEDLER //et al.//: 2A/14,15 vs 2D/20,21,22,23: Matches.
* STICKCHK: 2A/16 vs 2D/23: Matches
* SETMAXDB: 2A/16 vs 2D/24: Matches
* SETMINDB: 2A/16 vs 2D/24: Matches
* AMBGUPDT: 2A/17 vs. 2D/25: Matches
* DPADD: 2A/18,19 vs 2D/26,27: Matches
* SMALLMP: 2A/20 vs 2D/28: Matches

==== V79 ====

=== Background ===

The V79 subroutine is missing from the Colossus 2C flowchart because it is newly-introduced in Colossus 2C. Here's are some factoids of greater or lesser relevance:

* This is the so-called "BBQ mode", described in detail by [[https://www.ibiblio.org/apollo/Documents/COL203.pdf|COLOSSUS Memo #203]], "PCR815/V79/ R64/PTC - ORBRATE Routine".
* There is also considerable [[https://www.ibiblio.org/apollo/Documents/HSI-208472.pdf#page=29|GSOP description]], though unfortunately we have only the Colossus 2E GSOP, at which point PCR-292 and PCR-867 had caused the behavior to change somewhat from Colossus 2C.
* [[https://www.ibiblio.org/apollo/Documents/HSI-38170.pdf#page=6|PCR-815]] (referenced in the Memo #203's title) is itself titled "Digital autopilot barbecue mode routine". An SCB description of the PCR is
	This PCR changes the command module digital autopilot to provide a convenient way of setting up automatic GNCS attitude control for the cislunar passive thermal control and for orbit rate torquing around the moon.
* Note also [[https://www.ibiblio.org/apollo/Documents/COL217.pdf|COLOSSUS Memo #217]], "Performance of R64 Y axis option at a rate = .0507 with CDUX = 180 deg", though it is not extremely useful since its perspective is largely that of an end-user as opposed to an implementer.
* Incorporation of PCR-292 (Colossus 2E, "Add Time Display to V79", of which we have no copy) at some point between Comanche 84 and 89 is described by COLOSSUS Memo #243 as "a coding error in R64 was corrected". PCR-292 was also incorporated into Artemis at some point between Artemis 25 and 28, which COLOSSUS Memo #260 describes as follows:
	A time delay option was added to R64. V06N16 (Rl, R2, R3=0) is displayed initially; a PROCEED with zero time causes the selected rate control to be immediately effective. A non-zero time (G.E.T.) may be loaded which will delay the implementation of the selected rate control until the specified G.E.T. The uplink activity light is turned on when the rate control starts. This option is not available during P00; if R64 is selected during P00, the V06N16 display is bypassed and rate control proceeds immediately with no uplink activity light. (PCR 292)
* PCR-867 (Colossus 2E, "Make R64Y Rotation Fix") is also something we don't have.

Previous analysis of the BBQ-mode issue had gone nowhere and did not end up incorporating any code into the reconstruction.

=== First Confusing Side-Issue ===

//One// confusing point is that in the flowchart document, we find several places where "R64" appears in the table of contents, title blocks, etc., but not in the actual flowcharts. We find this in FC-2360 (titled "R64 (R05) - S-Band Antenna") and in FC-2606 (titled "V94 (R64)" or Cislunar Tracking). I think that as far as FC-2360 is concerned, it has nothing whatever to do with the (real) R64 for V79. In FC-2360, while the table of contents does reference R64, that reference has disappeared in the title block of the flowchart, which simply reads "R05 S-Band Antenna".

As far as FC-2606 is concerned, I am not quite as certain. But as near as I can make out, V94 has nothing to do with BBQ mode. So I'm going to say it should just be ignored.

=== Second Confusing Side-Issue ===

//Another// confusing point (to me) is that all of the documentation discusses R64, but we can only find a flowchart for V79. Nowhere can we find a flowchart for R64 itself.

As far as I can tell, the Colossus autopilot //always// had of automatically maintaining a constant roll from a given initial orientation, and thus PCR-815 requires no additional code to implement that behavior. The problem, rather, was that a series cumbersome steps was needed for the astronauts to maneuver to the desired initial orientation, set up the deadband, set up the roll rate, and then initiate the automatic operation. V79 instead provides an easier way of entering those parameters and starting the automatic guidance, though I guess maneuvering to the initial orientation was still something that needed to be done separately beforehand.

In other words, given that there's no need of any additional code beyond this parameter-input functionality, I guess that V79 and R64 are really one and the same thing; the V79 flowchart comprises the entirety of R64.

=== General Analysis ===

Unfortunately, now a lot more guessing begins!

1. Where should the code go? Well, firstly, the entry point should be called "V79" just as in the flowchart.
2. V79 itself should go into EXTENDED VERBS, since that's what V79 is. If there were an actual entry point called "R64" in the flowchart, and V79 called R64, then perhaps R64 should go elsewhere, but there isn't a separate R64. So I presume the entirety of V79's flowchart should probably go into EXTENDED VERBS.
3. Where in EXTENDED VERBS? 
	* What immediately precedes V79 in the //flowchart// is DONOUN48. In the //code//, in fan-out table GOEXTVB, what immediately follows the table position where V79 will appear is: TC LEMVEC / TC CSMVEC / TC V82PERF / TC V83PERF / .... In the actual code (rather than the fan-out table) of EXTENDED VERBS, DONOUN48 is immediately followed by V82PERF. (LEMVEC and CSMVEC are off in the boonies somewher.) It seems to me that putting V79 in between DONOUN48 and V82PERF in the code makes a kind of sense. Unfortunately, placing it there causes severe regressions, and we drop from the current 8 resolved memory banks to just 6. So this is not a good place to put it.
	* Moving V79 to later in EXTENDED VERBS restores first one of the resolved banks, and then the other. (And moving it still later doesn't change that.) While experimenting with that, I observed the code (as opposed to the table entries) for V76, V77, and V87 appear consecutively, and putting V79 between the code for V77 and V87 appears somewhat logical. All of the 8 resolved memory banks remain resolved with that placement, and there are no other obviously-bad side effects, so that seems to be a good placement ... for now.
4. What memory bank should V79 be? Well, GOEXTVB is in bank 43, so V79 must start there as well. Bank 43 has only 9 words remaining at this point in the reconstruction, so there's not enough space there for everything, and therefore the remainder will have to be placed in a different bank.
5. In what memory bank should the "remainder" of V79 go? In the most efficient basic (as opposed to interpretive) coding I have been able to devise so far, RATEMANU can fit in bank 43 (with 0 words to spare) and from RATECOMP onward can fit in bank 16 (with 0 words to spare). Interpretive coding might make it smaller, but my //guess//at this point is that doing so would be unlikely to save the 8 words necessary to cram the remainder into bank 17 instead. Of course, the remainder could also be split among several banks. Or stuff could be moved out of other banks.
6. New erasables: RATEPTC, DBPTC, OPTPTC. COLOSSUS Memo #203 mentions that "The erasable locations used for N79 are shared locations so data in N79 is not necessarily saved from the previous use of V79", referring to where the data entered via V06N79 (and used by V79/R64). Although V79 had disappeared from Colossus 3, the RATEPTC and DBPTC (but not OPTPTC) variables persist. You can see references to them in the table IDADDTAB in PINBALL NOUN TABLES, and see them allocated in ERASABLE ASSIGNMENTS, where they are inserted between SAVBNK and R61CNTR. 
	* Adding the references in PINBALL NOUN TABLES clearly must be done, and must be done in exactly one way. Since that turns out to be tricky, I separate the analysis into a separate section.
	* ERASABLE ASSIGNMENTS requires a bit of thought, because the area used in Artemis may not be appropriate for Comanche, and because at this stage of the reconstruction we are pretty confident of the layout of erasable memory, and don't want to add or subtract words from it that would displace the addresses of the succeeding variables. So in Artemis, RATEPTC/DBPTC occupy 2 words of memory between SAVBNK and R61CNTR, whereas in Comanche 55, there is already a 3-word variable (SAVEDCDU) occupying that position. Thus the amount of space that would be provided by sharing SAVEDCDU would be perfect for RATEPTC/DBPTC/OPTPTC. The comments indicate that SAVEDCDU is "CRS61.1 STORAGE FOR AUTOPILOT BANK" and that it is "TMP", so the question is whether CRS61.1 and BBQ mode can ever need this space simultaneously.


=== PINBALL NOUN TABLES ===

In PINBALL NOUN TABLES, it seems that the variables (RATEPTC, DBPTC, OPTPTC) set up by V06N79 must be added to 4 separate tables: IDADDTABNNADTAB, NNTYPTAB, and RUTMXTAB.

IDADDTAB: This is actually straightforward, because there's only one way to do it, so there's no need to discuss it. The other tables are trickier, since the entries are encoded and Artemis has no 3rd component for V06N79, so we can't just blindly copy what Artemis has.

NNADTAB: In Artemis, the value is 24165₈. As I figure it, for "mixed nouns" (N40 through N99) such as N79, the entries in NNADTAB are encoded as follows:

* Bit 15: "No load". This means that if any data is entered, the DSKY's OPR ERR indicator lamp will be illuminated. We wouldn't expect this bit to be set for our situation, and indeed it is not set in 24165₈.
* Bit 14: "Decimal only". This means that octal data is entered, the OPR ERR lamp will be illuminated. This bit is set in 24165₈, which makes sense if only RATEPTC and DBPTC are being entered in Artemis, but once OPTPTC comes into the mix I'm not sure it makes sense for Comanche 67. I think it should probably be 0 for us.
* Bit 13: "Octal only"? At any rate, it doesn't apply to our case and should be 0.
* Bits 12-11: The number of variables which will be affected, minus 1. In other words, 0=spare, 1=two components, 2=three components. (There's no option for just one component.) Thus we'd need to have a value of 2 for Comanche 67, but would expect a value of 1 for Artemis, and indeed that's exactly what we find.
* Bits 10-1: An offset into IDADDTAB of the 3 consecutive ECADRs pointing to the (2 or 3) variables which are going to be affected. For N79, this would appear to be (79-40)\*3=117₁₀=165₈. And indeed, that's what we already find in 24165₈.

NNTYPTAB: In Artemis, the value if 00113₈. It appears to me that for mixed nouns, the value is parses as follows:

* Bits 15-11: Scale-factor constant code for component 3 (or 0 if no 3rd component).
* Bits 10-6: Scale-factor constantcodefor component 2 (or 0 if no 2nd component, though given how NNADTAB is encoded, I don't see how that's possible).
* Bits 5-1: Scale-factor constantcodefor component 1.

The "scaling-factor constant code number". The comments in the Comanche 55 source code list the following possible values (in binary):

'''
	#	00000 WHOLE USE ARITH
	#	00000 DP TIME SEC (XXX.XX SEC)	USE ARITHDP1
	#	00001 SPARE
	#	00010 CDU DEGREES USE CDU DEGREES
	#	00010 Y OPTICS DEGREES USE Y OPTICS DEGREES
	#	00011 DP DEGREES (90) XX.XXX DEG	USE ARITHDP3
	#	00100 DP DEGREES (360) XXX.XX DEG	USE ARITHDP4
	#	00101 DEGREES (180) XXX.XX DEG	USE ARITH
	#	00110 WEIGHT2 (XXXXX. LBS) USE ARITH1
	#	00111 POSITION5 (XXX.XX NAUTICAL MILES)
	# 						USE ARITHDP3
	#	01000 POSITION4 (XXXX.X NAUTICAL MILES)
	# 						USE ARITHDP3
	#	01001 VELOCITY2 (XXXXX. FT/SEC)	USE ARITHDP4
	#	01010 VELOCITY3 (XXXX.X FT/SEC)	USE ARITHDP3
	#	01011 ELEVATION DEGREES (89.999 MAX)	USE ARITH
	#	01100 TRIM DEGREES (XXX.XX DEG)	USE ARITH
	#	01101 INERTIA (XXXXXBB. SLUG FT FT)	USE ARITH
	#	01101 THRUST MOMENT (XXXXXBB. FT LBS)	USE ARITH
	#	01110 VELOCITY/2VS (XXXXX. FT/SEC)	USE ARITHDP4
	#	01111 POSITION6 (XXXX.X NAUT MI)	USE ARITHDP3
	#	10000 DRAG ACCELERATION (XXX.XX G)	USE ARITHDP2
	#	10001 POSITION8 (XXXX.X NAUT MI)	USE ARITHDP3
	#	10010 POSITION9 (XXXXX. FT) USE ARITHDP4
	#	10011 VELOCITY4 (XXXX.X FT/SEC)	USE ARITHDP2
'''

Parsing out 00113₈, we find that in Artemis,

* Component #1 (RATEPTC) has the code 01011, or "ELEVATION DEGREES (89.999 MAX)"
* Component #2 (DBPTC) has the code 00010, or "CDU DEGREES" or "Y OPTICS DEGREES"
* Component #3 (unused in Artemis) has the code 00000, or "WHOLE"

I don't have much idea whether the first two of these make any sense or not. COLOSSUS Memo #203 tells us that the first component is "displayed to .0001 deg/sec" while the second component is "displayed to .01 deg". But there don't seem to be any scaling-factor constants consistent with the former (so 01011 is the closest). As for the latter, [[https://www.ibiblio.org/apollo/hrst/archive/1706.pdf#page=70|the "Keyboard and Display Program and Operation" document]] tells use that

'''
	00010             CDU Degrees (XXX.XX deg.)
	00010             Y Optics Degrees (XX.XXX deg.)
'''

Well, I suppose it must be right, even if I don't quite understand it. As far as the third component is concerned, though, "WHOLE" seems exactly right. So it appears to me that the Artemis value works fine for Comanche 67.

RUTMXTAB: In Artemis the value is 00103₈. These values are also parsed out into 3 components, as

* Bits 15-11: Scale-factor routine code for component 3 (or 0 if no 3rd component).
* Bits 10-6: Scale-factor routinecodefor component 2 (or 0 if no 2nd component).
* Bits 5-1: Scale-factor routinecodefor component 1.

The Comanche 55 source code lists the possible scale-factor routine codes as:

'''
	# 	00000 OCTAL ONLY
	#	00001 STRAIGHT FRACTIONAL
	#	00010 CDU DEGREES (XXX.XX)
	#	00011 ARITHMETIC SF
	#	00100 ARITH DP1	OUT (MULT BY 2EXP14 AT END)	IN (STRAIGHT)
	#	00101 ARITH DP2	OUT (STRAIGHT)   		IN (SL 7 AT END)
	#	00110 Y OPTICS DEGREES (XX.XXX MAX 89.999)
	#	00111 ARITH DP3	OUT (SL 7 AT END) 		IN (STRAIGHT)
	#	01000 WHOLE HOURS IN R1, WHOLE MINUTES (MOD 60) IN R2,
	# 	      SECONDS (MOD 60) 0XX.XX IN R3.  *ALARMS IF USED WITH OCTAL
	#	01001 MINUTES (MOD 60) IN D1D2, D3 BLANK, SECONDS (MOD 60) IN D4D5
	# 	      LIMITS TO 59B59 IF MAG EXCEEDS THIS VALUE.
	# 	      ALARMS IF USED WITH OCTAL**** 		IN (ALARM)
	#	01010 ARITH DP4	OUT (STRAIGHT) IN (SL 3 AT END)
	#	01011 ARITH1 SF	OUT (MULT BY 2EXP14 AT END)	IN (STRAIGHT)
	#	01100 2 INTEGERS IN D1D2, D4D5, D3 BLANK.
	# 	      ALARMS IF USED WITH OCTAL ****** 		IN (ALARM)
	#	01101 DP STRAIGHT FRACTIONAL
'''

Parsing out 00103₈, we find that in Artemis,

* Component #1 (RATEPTC) has the code 00011, or "ARITHMETIC SF"
* Component #2 (DBPTC) has the code 00010, or "CDU DEGREES (XXX.XX)"
* Component #3 (unused in Artemis) has the code 00000, or "OCTAL ONLY"

Assuming that the first two are correct for Comanche 67 as well, I'd note only that "OCTAL ONLY" seems like exactly what's needed for OPTPTC, so the Artemis value seems appropriate for Comanche 67.

==== Preprocessor Labels for Conditional Assembly ====

* For incorporation of FC-2370 //other than// V79/R64/PCR-815: ReconstructionFC2370.
* For incorporation of V79/R64/PCR-815 specifically: Reconstruction815. Additionally, if Reconstruction815 is #define'd then both of the following must be defined (and assigned values) as well:
	* Memory bank to use for subroutine RATEMANU //et seq.//: bankRATEMANU
	* Memory bank to use for subroutine RATECOMP //et seq.//: bankRATECOMP

